<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Unity WebGL Player | Ant-algorithm</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
  </head>
  <body>
    <div>
    <p>Муравьиный алгоритм - алгоритм нахождения приближённого решения задачи коммивояжёра.
      Алгоритм подражает поведению настоящих муравьёв, как бы запуская по пути муравьёв, которые бегают и оставляют феромон на пути своего следования, тем больше, тем короче путь, а уже другие муравьи, выбирая свой следующий путь ориентируются на этот феромон, чаще выбирая тот путь где его больше.</p>
      <h4 id="-">Это всё хорошо, но зачем так мудрить?</h4>
      <p>Чтоб ответить на этот вопрос давайте просто подумаем как долго будет перебрать все возможные пути для графа размером n?
      Давайте разбирается:
      Для первой вершины у нас есть n-1 возможных вариантов пути, для следующей уже n-2, далее n-3 и так пока не дойдём до нуля. То есть выходит, что нам надо рассматривать $(n-1)!$ путей? Всё-таки не совсем. Задача коммивояжёра симметричная, а значит, можно рассмотреть всего $\frac{(n-1)!}{2}$ и вроде кажется, что можно выдыхать, но нет, давайте посмотрим сколько вариантом надо будет рассмотреть для разных n:</p>
      <table>
      <thead>
      <tr>
      <th style="text-align:center">n</th>
      <th style="text-align:center">кол-во вариантов</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td style="text-align:center">4</td>
      <td style="text-align:center">3</td>
      </tr>
      <tr>
      <td style="text-align:center">5</td>
      <td style="text-align:center">12</td>
      </tr>
      <tr>
      <td style="text-align:center">6</td>
      <td style="text-align:center">60</td>
      </tr>
      <tr>
      <td style="text-align:center">7</td>
      <td style="text-align:center">360</td>
      </tr>
      <tr>
      <td style="text-align:center">8</td>
      <td style="text-align:center">2520</td>
      </tr>
      <tr>
      <td style="text-align:center">9</td>
      <td style="text-align:center">20160</td>
      </tr>
      <tr>
      <td style="text-align:center">10</td>
      <td style="text-align:center">181440</td>
      </tr>
      <tr>
      <td style="text-align:center">11</td>
      <td style="text-align:center">1814400</td>
      </tr>
      <tr>
      <td style="text-align:center">12</td>
      <td style="text-align:center">19958400</td>
      </tr>
      <tr>
      <td style="text-align:center">13</td>
      <td style="text-align:center">239500800</td>
      </tr>
      <tr>
      <td style="text-align:center">14</td>
      <td style="text-align:center">3113510400</td>
      </tr>
      <tr>
      <td style="text-align:center">15</td>
      <td style="text-align:center">43589145600</td>
      </tr>
      </tbody>
      </table>
      <p>И тут мы приходим к факту, что уже для всего 66 вершин задача практически нерешаема перебором, а часто мы хотим рассмотреть значительно больше вершин.</p>
      <h4 id="-">Зачем мне эти ваши компутеры, я и сам всё могу!</h4>
      <p>Что интересно, человек очень просто решает множество очевидных задач коммивояжёра приходя к близкому к идеальному решение просто взглянув на схему и прикинув возможные пути. Но, во-первых, нам нужно эту схему нарисовать, расположить все расстояния и графически показать цену перехода, а во-вторых, это не интересно!</p>
      <h4 id="-">Давайте потрошить алгоритм!</h4>
      <p>Первым делом нам нужно завести две матрицы. Первая, которую обзовём $\tau$ будет хранить все матрицу смежности для всех вершин, а вторая - $\eta$ будет хранить в себе кол-во феромона на переходе из вершины в вершину.</p>
      <p>Далее нужен цикл, а точнее даже два цикла, ведь в сути своей кол-во муравьёв ($N$) это сколько раз нам нужно запустить алгоритм поиска пути до изменений феромона.</p>
      <p>Пускаем муравьёв. И они никуда не двигаются... А потому что они не знают куда! А для этого уже нужна формула, которая <strong>будет определят шанс перехода из вершины в вершину</strong>, а так же госпожа Удача, которая милостиво даст нам число от 0 до 1. Нам же остаётся взглянуть на формулу:
      $$
      P<em>{k; i,j} = \frac {{\frac{1}{\eta}}^\alpha</em>{i,j} \cdot \tau_{i,j} ^ \beta}{\sum<em>m {\frac{1}{\eta}}^\alpha</em>{m} \cdot \tau_{m} ^ \beta}
      $$
       Где $\alpha$ и $\beta$ - константы
      Переводя с математического на русский тут сказано, что шанс перейти из вершины i в j для муравья k равен обратному расстояния в степени бета умноженному на кол-во феромона в степени альфа, делённому на сумму всех таких множеств.
      Таким образом получаем, что чем меньше расстояния от i к j, и чем больше феромона лежит от i к j, то тем больше шанс, что муравей выберет этот путь.</p>
      <p>Итак мы выбрали путь, и прошли его, и даже запомнили его длинную как $L_k$, а сам путь в множество $T<em>k$, как мы будем менять феромон? А тут тоже всё просто и подлежит простым формулам. Итак формула <strong>вклада феромона от муравья k</strong> будет такой:
      $$
      \Delta \tau</em>{k; i,j} = \begin{cases} \frac{Q}{L_k} \text{ если } i, j \in T_k \ 0 \text{ если } i,j \notin T_k \end{cases}
      $$
       Где Q - константа.
      Это формула обозначает, что муравей k на каждый из путей по которому он прошёл будет класть феромон в кол-во равном его Q делённом на его путь.</p>
      <p>Также надо добавить <strong>испарение феромона</strong>, чтобы система была динамичной. Для этой, как ни странно, тоже есть своя формула: 
      $$
      \tau<em>{i,j} = \rho \tau</em>{i,j} + \sum^N<em>{k=0} \Delta\tau</em>{k; i,j}
      $$
      Где $\rho$ - константа
      Фактически эта формула означает, что кол-во феромона между i,j после прохода всех муравьёв будет равно его кол-во с прошлой итерации плюс сумма всех вкладов муравьёв. Логично предположить, что здесь $\rho$ должно быть в диапазоне от 0 до 1.</p>
      <p>И всё! Эти 3 формулы описывают весь алгоритм, так что давайте разберём его на простом примере:</p>
      <h4 id="-">Компилируем код на листочке, пример:</h4>
      <p>Пусть у нас будут 4 вершины, 4 муравья, а все константы, кроме $\rho$  будут равны 1, чтобы о них забыть, $\rho$ же будет равно 0,5.</p>
      <p>Итак, да будет матрица смежности!</p>
      <table>
      <thead>
      <tr>
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1,5</td>
      <td>1</td>
      </tr>
      <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1,5</td>
      </tr>
      <tr>
      <td>2</td>
      <td>1,5</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      </tr>
      <tr>
      <td>3</td>
      <td>1</td>
      <td>1,5</td>
      <td>1</td>
      <td>0</td>
      </tr>
      </tbody>
      </table>
      <p>И конечно же не забудем про матрицу феромонов, там назначит начальным значением 0,2</p>
      <table>
      <thead>
      <tr>
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td>0</td>
      <td>0</td>
      <td>0,2</td>
      <td>0,2</td>
      <td>0,2</td>
      </tr>
      <tr>
      <td>1</td>
      <td>0,2</td>
      <td>0</td>
      <td>0,2</td>
      <td>0,2</td>
      </tr>
      <tr>
      <td>2</td>
      <td>0,2</td>
      <td>0,2</td>
      <td>0</td>
      <td>0,2</td>
      </tr>
      <tr>
      <td>3</td>
      <td>0,2</td>
      <td>0,2</td>
      <td>0,2</td>
      <td>0</td>
      </tr>
      </tbody>
      </table>
      <p>Всё это выходит в такой красивый граф:</p>
      <p><img src="example-1.png" alt="Пример, рис-1"></p>
      <ul>
      <li>Пускам первого муравья, пусть его путь будет 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 0 и его длинна будет равна 4. Тогда на каждое ребро он положит $\frac{1}{4} = 0,25$  феромона. </li>
      <li>Второй пройдёт по пути 1 -&gt; 3 -&gt; 2 -&gt; 0 -&gt; 1 его путь уже будет равен 5 и на каждое ребро уже он положит 0,2 феромона</li>
      <li>У третьего путь: 2 -&gt; 3 -&gt; 1 -&gt; 0 -&gt; 2, длинна 5, феромона 0,2</li>
      <li>Ну и у четвёртого 3 -&gt; 2 -&gt; 1 -&gt; 0 -&gt; 3, длинна 4, феромона 0,25</li>
      </ul>
      <p>Самое время обновлять таблицу феромонов:
      Каждое значение надо умножить на 0,5; таким образом 0,2 станет 0,1 и к каждому надо будет прибавить посчитанные ранее значения. Не буду это расписывать, лучше покажу результат:</p>
      <table>
      <thead>
      <tr>
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0,5</td>
      <td>0,6</td>
      </tr>
      <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0,8</td>
      <td>0,3</td>
      </tr>
      <tr>
      <td>2</td>
      <td>0,5</td>
      <td>0,8</td>
      <td>0</td>
      <td>1</td>
      </tr>
      <tr>
      <td>3</td>
      <td>0,6</td>
      <td>0,3</td>
      <td>1</td>
      <td>0</td>
      </tr>
      </tbody>
      </table>
      <p>И следовательно граф становиться таким:</p>
      <p><img src="example-2.png" alt="Пример рис-2"></p>
      <p>Уже на этом этапе видно что намечается очевидный фаворит более короткого пути, но при этом так выпал случай, что 0-3 ребро имеет мало феромона. В любой случае, предлагаю посмотреть ещё один шаг:</p>
      <ul>
      <li>Первый: 0 -&gt; 3 -&gt; 2 -&gt; 1 - &gt; 0, путь 4, вклад 0,25</li>
      <li>Второй  1 -&gt; 3-&gt; 0 -&gt; 2 -&gt; 1, путь 5, вклад 0,2</li>
      <li>Третий 2 -&gt; 3 -&gt; 0 -&gt; 1 -&gt; 2, путь 4, вклад 0,25</li>
      <li>Четвёртый 3-&gt;2-&gt;1-&gt;0-&gt;3, путь 4, вклад 0,25</li>
      </ul>
      <p>Матрица:</p>
      <table>
      <thead>
      <tr>
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td>0</td>
      <td>0</td>
      <td>1,25</td>
      <td>0,45</td>
      <td>1</td>
      </tr>
      <tr>
      <td>1</td>
      <td>1,25</td>
      <td>0</td>
      <td>1,15</td>
      <td>0,15</td>
      </tr>
      <tr>
      <td>2</td>
      <td>0,45</td>
      <td>1,15</td>
      <td>0</td>
      <td>1,25</td>
      </tr>
      <tr>
      <td>3</td>
      <td>1</td>
      <td>0,15</td>
      <td>1,25</td>
      <td>0</td>
      </tr>
      </tbody>
      </table>
      <p>Граф
      <img src="example-3.png" alt="Пример, рис-1"></p>
      <p>И тут уже очевиден фаворит по длине пути.</p>
      <h4 id="-">А можно лучше?</h4>
      <p>Муравьиный алгоритм существует уже очень давно и поэтому оброс разными улучшениями. Здесь нет цели вдаваться в их подробности, но заострю внимание на улучшении  c &quot;элитными&quot; муравьями: такие ходят только по лучшему пути, что значит, что на такой путь каждый цикл добавляется феромон, что заставляет следующих муравьёв чаще искать путь, который как-то изменяет прошлый наилучший</p>
      <h4 id="-">Код, мне нужен код!</h4>
      <p>Осталось немного. Написать код который делает решает этот алгоритм. Я написал его на C# под Unity  полный код найдёте по <a href="vk.com">этой ссылке</a>. А тут же покажу код самого алгоритма с подробными комментариями:</p>
      <pre><code class="lang-csharp"><span class="hljs-comment">// Объявление переменных для алгоритма муравьиной колонии</span>
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> alpha, beta, Q, ro, startPheromone, minPheromone; <span class="hljs-comment">// Параметры алгоритма</span>
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> antCount = <span class="hljs-number">1</span>; <span class="hljs-comment">// Количество муравьев</span>
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> eliteAntCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Количество элитных муравьев</span>
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> iteration = <span class="hljs-number">0</span>; <span class="hljs-comment">// Счетчик итераций</span>
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> pathSize = <span class="hljs-number">0.0</span>f; <span class="hljs-comment">// Длина лучшего найденного пути</span>
      
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span>[,] adjMatrix; <span class="hljs-comment">// Матрица смежности графа</span>
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span>[,] pheromoneMatrix; <span class="hljs-comment">// Матрица феромонов</span>
      
      <span class="hljs-comment">// Структура для представления муравья</span>
      <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Ant
      {
          <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> currentPoint { <span class="hljs-keyword">set</span>; <span class="hljs-keyword">get</span>; } <span class="hljs-comment">// Текущая позиция муравья</span>
          <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span>[] visitedPoints { <span class="hljs-keyword">set</span>; <span class="hljs-keyword">get</span>; } <span class="hljs-comment">// Массив посещенных точек</span>
          <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> visitedPointsCounter; <span class="hljs-comment">// Счетчик посещенных точек</span>
          <span class="hljs-keyword">public</span> List&lt;<span class="hljs-keyword">int</span>&gt; path; <span class="hljs-comment">// Путь, пройденный муравьем</span>
          <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> pathLength; <span class="hljs-comment">// Длина пути</span>
          <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isElite; <span class="hljs-comment">// Флаг, указывающий, является ли муравей элитным</span>
      
          <span class="hljs-comment">// Конструктор для инициализации муравья</span>
          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Ant</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> point, <span class="hljs-keyword">int</span> adjMatrixLength, <span class="hljs-keyword">bool</span> Elite</span>)
          </span>{
              <span class="hljs-keyword">this</span>.currentPoint = point; <span class="hljs-comment">// Установка текущей точки</span>
              <span class="hljs-keyword">this</span>.visitedPoints = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>[adjMatrixLength]; <span class="hljs-comment">// Инициализация массива посещенных точек</span>
              <span class="hljs-keyword">this</span>.visitedPointsCounter = <span class="hljs-number">0</span>; <span class="hljs-comment">// Инициализация счетчика</span>
              <span class="hljs-keyword">this</span>.path = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;(); <span class="hljs-comment">// Инициализация списка пути</span>
              <span class="hljs-keyword">this</span>.pathLength = <span class="hljs-number">0.0</span>f; <span class="hljs-comment">// Инициализация длины пути</span>
              <span class="hljs-keyword">this</span>.isElite = Elite; <span class="hljs-comment">// Установка флага элитности</span>
          }
      }
      
      <span class="hljs-comment">// Метод, вызываемый при старте</span>
      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)
      </span>{
          <span class="hljs-comment">// Получение матрицы смежности из контроллера графа</span>
          adjMatrix = graphController.GetAdjMatrix();
          <span class="hljs-keyword">if</span> (adjMatrix.Length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Если матрица пуста, выходим из метода</span>
      
          <span class="hljs-comment">// Инициализация матрицы феромонов</span>
          pheromoneMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[adjMatrix.GetLength(<span class="hljs-number">0</span>), adjMatrix.GetLength(<span class="hljs-number">1</span>)];
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; pheromoneMatrix.GetLength(<span class="hljs-number">0</span>); x++)
          {
              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; pheromoneMatrix.GetLength(<span class="hljs-number">1</span>); y++)
              {
                  <span class="hljs-comment">// Установка феромонов на диагонали в 0 (муравей не может вернуться в ту же точку)</span>
                  <span class="hljs-keyword">if</span> (x == y) pheromoneMatrix[x, y] = <span class="hljs-number">0</span>;
                  <span class="hljs-keyword">else</span> pheromoneMatrix[x, y] = startPheromone; <span class="hljs-comment">// Установка начального значения феромонов</span>
              }
          }
      
          <span class="hljs-comment">// Запуск основного цикла алгоритма</span>
          StartCoroutine(Main());
      }
      
      <span class="hljs-comment">// Основной метод алгоритма</span>
      <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)
      </span>{
          <span class="hljs-keyword">int</span> vertexCount = adjMatrix.GetLength(<span class="hljs-number">0</span>); <span class="hljs-comment">// Количество вершин в графе</span>
          <span class="hljs-keyword">float</span> minLength = <span class="hljs-keyword">float</span>.MaxValue; <span class="hljs-comment">// Минимальная длина пути</span>
          List&lt;<span class="hljs-keyword">int</span>&gt; bestPath = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;(); <span class="hljs-comment">// Лучший найденный путь</span>
          <span class="hljs-keyword">int</span> startVertex = <span class="hljs-number">0</span>; <span class="hljs-comment">// Начальная вершина</span>
      
          <span class="hljs-comment">// Бесконечный цикл для итераций алгоритма</span>
          <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
          {
              <span class="hljs-comment">// Матрица для добавления феромонов</span>
              <span class="hljs-keyword">float</span>[,] pheromoneAdd = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[pheromoneMatrix.GetLength(<span class="hljs-number">0</span>), pheromoneMatrix.GetLength(<span class="hljs-number">1</span>)];
      
              <span class="hljs-comment">// Цикл по количеству муравьев</span>
              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> antNum = <span class="hljs-number">0</span>; antNum &lt; antCount; antNum++)
              {
                  <span class="hljs-comment">// Создание нового муравья</span>
                  Ant ant = <span class="hljs-keyword">new</span> Ant(startVertex % vertexCount, vertexCount, antNum &gt;= (antCount - eliteAntCount));
                  startVertex++; <span class="hljs-comment">// Переход к следующему муравью</span>
      
                  <span class="hljs-comment">// Цикл, пока муравей не посетит все вершины</span>
                  <span class="hljs-keyword">for</span> (; ant.visitedPointsCounter &lt; vertexCount; ant.visitedPointsCounter++)
                  {
                      <span class="hljs-keyword">if</span> (!ant.isElite) <span class="hljs-comment">// Если муравей не элитный</span>
                                      {
                          <span class="hljs-keyword">float</span> sum = <span class="hljs-number">0.0</span>f; <span class="hljs-comment">// Переменная для хранения суммы вероятностей</span>
                          List&lt;<span class="hljs-keyword">int</span>&gt; possible = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;(); <span class="hljs-comment">// Список возможных вершин для перехода</span>
      
                          <span class="hljs-comment">// Цикл по всем вершинам для нахождения возможных переходов</span>
                          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexCount; i++)
                          {
                              <span class="hljs-comment">// Пропускаем уже посещенные вершины и текущую вершину</span>
                              <span class="hljs-keyword">if</span> (ant.visitedPoints[i] || i == ant.currentPoint) <span class="hljs-keyword">continue</span>;
      
                              <span class="hljs-comment">// Вычисляем вероятность перехода к вершине i</span>
                              sum += Mathf.Pow(pheromoneMatrix[ant.currentPoint, i], alpha) * Mathf.Pow(<span class="hljs-number">1.0</span>f / adjMatrix[ant.currentPoint, i], beta);
                              possible.Add(i); <span class="hljs-comment">// Добавляем вершину в список возможных</span>
                          }
      
                          <span class="hljs-comment">// Если нет возможных переходов, добавляем текущую точку в путь и выходим из цикла</span>
                          <span class="hljs-keyword">if</span> (possible.Count == <span class="hljs-number">0</span>)
                          {
                              ant.path.Add(ant.currentPoint);
                              <span class="hljs-keyword">break</span>;
                          }
      
                          <span class="hljs-comment">// Генерируем случайное число для выбора следующей вершины</span>
                          <span class="hljs-keyword">float</span> randomPoint = Random.Range(<span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f);
                          <span class="hljs-keyword">float</span> marker = <span class="hljs-number">0.0</span>f; <span class="hljs-comment">// Переменная для накопления вероятностей</span>
                          <span class="hljs-keyword">int</span> nextPoint = possible[<span class="hljs-number">0</span>]; <span class="hljs-comment">// Начальное значение следующей точки</span>
      
                          <span class="hljs-comment">// Цикл по возможным вершинам для выбора следующей точки</span>
                          <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">int</span> point <span class="hljs-keyword">in</span> possible)
                          {
                              <span class="hljs-comment">// Если накопленная вероятность превышает случайное число, выбираем эту точку</span>
                              <span class="hljs-keyword">if</span> (marker &gt;= randomPoint)
                              {
                                  nextPoint = point;
                                  <span class="hljs-keyword">break</span>;
                              }
                              <span class="hljs-comment">// Накопление вероятности</span>
                              marker += Mathf.Pow(pheromoneMatrix[ant.currentPoint, point], alpha) * Mathf.Pow(<span class="hljs-number">1.0</span>f / adjMatrix[ant.currentPoint, point], beta) / sum;
                          }
      
                          <span class="hljs-comment">// Обновляем длину пути и добавляем следующую точку в путь</span>
                          ant.pathLength += adjMatrix[ant.currentPoint, nextPoint];
                          ant.path.Add(ant.currentPoint);
                          ant.visitedPoints[ant.currentPoint] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Отмечаем текущую точку как посещенную</span>
                          ant.currentPoint = nextPoint; <span class="hljs-comment">// Переходим к следующей точке</span>
                      }
                      <span class="hljs-keyword">else</span> <span class="hljs-comment">// Если муравей элитный</span>
                      {
                          <span class="hljs-comment">// Устанавливаем путь и длину пути как лучший найденный</span>
                          ant.path = bestPath;
                          ant.pathLength = minLength;
                      }
                  }
      
                  <span class="hljs-comment">// Вычисляем изменение феромонов на основе длины пути</span>
                  <span class="hljs-keyword">float</span> deltaTau = Q / ant.pathLength;
                  <span class="hljs-comment">// Обновляем матрицу феромонов на основе пройденного пути</span>
                  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ant.path.Count; i++)
                  {
                      pheromoneAdd[ant.path[i], ant.path[(i + <span class="hljs-number">1</span>) % ant.path.Count]] += deltaTau; <span class="hljs-comment">// Добавляем феромоны для ребра</span>
                      pheromoneAdd[ant.path[(i + <span class="hljs-number">1</span>) % ant.path.Count], ant.path[i]] += deltaTau; <span class="hljs-comment">// Добавляем феромоны для обратного ребра</span>
                  }
      
                  <span class="hljs-comment">// Если текущая длина пути меньше минимальной, обновляем минимальную длину и лучший путь</span>
                  <span class="hljs-keyword">if</span> (ant.pathLength &lt; minLength)
                  {
                      minLength = ant.pathLength; <span class="hljs-comment">// Обновляем минимальную длину</span>
                      bestPath = ant.path; <span class="hljs-comment">// Обновляем лучший путь</span>
                  }
              }
      
              <span class="hljs-comment">// Обновляем матрицу феромонов с учетом испарения и добавления новых феромонов</span>
              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; pheromoneMatrix.GetLength(<span class="hljs-number">0</span>); x++)
              {
                  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; pheromoneMatrix.GetLength(<span class="hljs-number">1</span>); y++)
                  {
                      <span class="hljs-comment">// Обновляем значение феромонов с учетом испарения и добавления новых</span>
                      pheromoneMatrix[x, y] = Mathf.Max(pheromoneMatrix[x, y] * ro + pheromoneAdd[x, y], minPheromone);
                  }
              }
      
              <span class="hljs-comment">// Ждем следующего кадра перед продолжением</span>
              <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          } 
      }
      </code></pre>
      <h4 id="-">А если я сам хочу?</h4>
      <p>Ну и кончено я хочу дать каждому попробовать разные параметры для данного алгоритма, поэтому ниже вы можете интерактивно попробовать разные параметры и найти лучшие для своего графа:</p>
    </div>



    <div id="unity-container" class="unity-desktop">
      <canvas id="unity-canvas" width=960 height=600></canvas>
      <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
          <div id="unity-progress-bar-full"></div>
        </div>
      </div>
      <div id="unity-warning"> </div>
      <div id="unity-footer">
        <div id="unity-webgl-logo"></div>
        <div id="unity-fullscreen-button"></div>
        <div id="unity-build-title">Ant-algorithm</div>
      </div>
    </div>
    <script>
      var container = document.querySelector("#unity-container");
      var canvas = document.querySelector("#unity-canvas");
      var loadingBar = document.querySelector("#unity-loading-bar");
      var progressBarFull = document.querySelector("#unity-progress-bar-full");
      var fullscreenButton = document.querySelector("#unity-fullscreen-button");
      var warningBanner = document.querySelector("#unity-warning");

      // Shows a temporary message banner/ribbon for a few seconds, or
      // a permanent error message on top of the canvas if type=='error'.
      // If type=='warning', a yellow highlight color is used.
      // Modify or remove this function to customize the visually presented
      // way that non-critical warnings and error messages are presented to the
      // user.
      function unityShowBanner(msg, type) {
        function updateBannerVisibility() {
          warningBanner.style.display = warningBanner.children.length ? 'block' : 'none';
        }
        var div = document.createElement('div');
        div.innerHTML = msg;
        warningBanner.appendChild(div);
        if (type == 'error') div.style = 'background: red; padding: 10px;';
        else {
          if (type == 'warning') div.style = 'background: yellow; padding: 10px;';
          setTimeout(function() {
            warningBanner.removeChild(div);
            updateBannerVisibility();
          }, 5000);
        }
        updateBannerVisibility();
      }

      var buildUrl = "Build";
      var loaderUrl = buildUrl + "/buid.loader.js";
      var config = {
        dataUrl: buildUrl + "/buid.data.unityweb",
        frameworkUrl: buildUrl + "/buid.framework.js.unityweb",
        codeUrl: buildUrl + "/buid.wasm.unityweb",
        streamingAssetsUrl: "StreamingAssets",
        companyName: "DefaultCompany",
        productName: "Ant-algorithm",
        productVersion: "1.0",
        showBanner: unityShowBanner,
      };

      // By default Unity keeps WebGL canvas render target size matched with
      // the DOM size of the canvas element (scaled by window.devicePixelRatio)
      // Set this to false if you want to decouple this synchronization from
      // happening inside the engine, and you would instead like to size up
      // the canvas DOM size and WebGL render target sizes yourself.
      // config.matchWebGLToCanvasSize = false;

      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        // Mobile device style: fill the whole browser client area with the game canvas:

        var meta = document.createElement('meta');
        meta.name = 'viewport';
        meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
        document.getElementsByTagName('head')[0].appendChild(meta);
        container.className = "unity-mobile";
        canvas.className = "unity-mobile";

        // To lower canvas resolution on mobile devices to gain some
        // performance, uncomment the following line:
        // config.devicePixelRatio = 1;

        unityShowBanner('WebGL builds are not supported on mobile devices.');
      } else {
        // Desktop style: Render the game canvas in a window that can be maximized to fullscreen:

        canvas.style.width = "960px";
        canvas.style.height = "600px";
      }

      loadingBar.style.display = "block";

      var script = document.createElement("script");
      script.src = loaderUrl;
      script.onload = () => {
        createUnityInstance(canvas, config, (progress) => {
          progressBarFull.style.width = 100 * progress + "%";
        }).then((unityInstance) => {
          loadingBar.style.display = "none";
          fullscreenButton.onclick = () => {
            unityInstance.SetFullscreen(1);
          };
        }).catch((message) => {
          alert(message);
        });
      };
      document.body.appendChild(script);
    </script>
  </body>
</html>
